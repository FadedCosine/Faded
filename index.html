<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/doughnut.svg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/doughnut32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/doughnut16x16.png?v=5.1.4">






  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Cosine">
<meta property="og:url" content="https://fadedcosine.github.io/index.html">
<meta property="og:site_name" content="Cosine">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cosine">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fadedcosine.github.io/">





  <title>Cosine</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cosine</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fadedcosine.github.io/2020/05/05/Neural-Machine-Reading-Comprehension-Methods-and-Trends/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cosine">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Zoe.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cosine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">论文笔记：Neural Machine Reading Comprehension：Methods and Trends</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T15:19:39+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/千里怀思月在峰/" itemprop="url" rel="index">
                    <span itemprop="name">千里怀思月在峰</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Neural-Machine-Reading-Comprehension-Methods-and-Trends"><a href="#Neural-Machine-Reading-Comprehension-Methods-and-Trends" class="headerlink" title="Neural Machine Reading Comprehension: Methods and Trends"></a>Neural Machine Reading Comprehension: Methods and Trends</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>这篇综述十分详尽地介绍了机器阅读理解（MRC）问题的问题背景，以及经典的MRC，并将大体的模型架构分模块，对每个模块都进行了详尽的方法介绍。然而，我觉得这篇文章并没有涉及预训练语言模型在MRC问题当中的应用，实属可惜。</p>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在2015年CNN &amp; Daily Mail数据集发布之后，机器阅读理解问题得以进行深度学习模型的训练。SQuAD数据集的发布更是加快了基于深度学习的机器阅读理解研究的发展。这一点，从15年到18年底这段时期机器阅读理解的研究论文的指数集增长便可以直观地体现出。</p>
<p>本综述的主要贡献包括：</p>
<ul>
<li>把各种各样的MRC任务归类为四类：完形填空类、多项选择类、答案抽取类、自由问答类。为每一类任务都介绍了代表的数据集</li>
<li>介绍了基于深度学习的MRC系统的大体模型架构，详细提供每个模块中使用的主要技术的概述和摘要</li>
<li>揭示了MRC研究的一些新趋势，讨论了目前存在的挑战和有待解决的问题，希望能找到未来的研究方向，对其他研究者有所启发。</li>
</ul>
<h2 id="Tasks-amp-Evaluation-Metrics"><a href="#Tasks-amp-Evaluation-Metrics" class="headerlink" title="Tasks &amp; Evaluation Metrics"></a>Tasks &amp; Evaluation Metrics</h2><h3 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h3><ol>
<li><p>Cloze Test（完型填空类）<br>此类任务类似于常见于英语试题中的完形填空部分。问题是通过删除文章中的一些单词或者命名实体来产生的，要求机器在被删除的空白处填上所缺的单词。任务可以选择提供候选答案，或者不提供候选答案。此类任务的代表数据集有CNN/Daily。</p>
</li>
<li><p>Multiple Choice（多项选择类）<br>此类任务类似于英语试题中的阅读理解部分。要求机器根据所提供的上下文从候选答案中选择问题的正确答案。与完形填空相比，多项选择题的答案并不局限于上下文中的单词或实体。但是，这个任务必须提供候选答案。此类任务的代表数据集有RACE</p>
</li>
<li><p>Span Extraction（答案抽取类）<br>尽管完型填空类和多项选择类的任务可以在某些程度上衡量机器在自然语言理解的能力，但依旧有些缺陷。比如说，单纯的文字或实体不足以回答问题，在某些情况下，需要一个完整的句子来回答问题，而且有些实际情况下，提出的问题可能根本就没有相应的答案。那么答案抽取式的任务就可以很好地解决以上的问题。此类任务给定上下文和问题，要求机器从相应的上下文中提取一段文本作为答案，其次根据数据集的不同，有些任务可能存在一些问题从上下文中无法提取答案，则要求机器判断出“No answer”。此类任务的代表数据集有SQuAD、SQuAD2.0。</p>
</li>
<li><p>Free Answering（自由问答类）<br>此类任务是MRC任务中最复杂的一个，给定上下文和问题，要求机器给出自己的解答，而且这个答案可能并不简单地是原文中的某个子串。此类任务的代表数据集有MS MARCO。其中MS MARCO数据集可以说是SQuAD数据集分布之后的又一个里程碑，MS MARCO数据集有四个主要的特征：一是所有的问题都是用户真实提出的；二是每个问题，都有10个由Bing搜索引擎得到的相关文档；三是问题对应的答案都是人为产生的，所以这些答案不仅仅是相关文档中的内容提取，而会包含对相关内容的研究和总结；四是由于是人为给出的答案，所以有可能有些答案是相矛盾的，这也更为机器的理解增添了难度。</p>
</li>
</ol>
<p><em>不同任务的比较：</em> 文章从construction, understanding, flexibility, evaluation and application五个方面对以上四类MRC任务做出了对比。</p>
<p>完形填空测试任务是最容易构建和评估数据集的。但是，由于填空的形式仅限于原始上下文中的单个单词或名称实体，所以完形填空不能很好地测试机器对自然语言的理解，与实际应用不符。多项选择题为每个问题提供候选答案，因此即使答案不局限于最初的上下文，也可以很容易地对它们进行评估。建立这个任务的数据集并不难，因为语言考试中的多项选择题很容易利用。然而，候选答案导致了合成数据集和实际应用之间的差距。相比之下，答案抽取式任务是一种适中的选择，因为数据集易于构造和评估。此外，它们可以在某种程度上测试机器对文本的理解。所有这些优点都有助于对这些任务进行大量的研究。答案抽取式任务的缺点是其结果受限于原始上下文的子序列，这与现实世界还有一定的距离。自由应答任务在理解性、灵活性和应用维度上表现出优越性，最接近于实际应用。然而，任何事物都有两面性。由于其答案形式的灵活性，在一定程度上很难构建数据集，如何有效地评估这些任务的性能仍然是一个独特的挑战。</p>
<h3 id="Evaluation-Metrics（评价指标）"><a href="#Evaluation-Metrics（评价指标）" class="headerlink" title="Evaluation Metrics（评价指标）"></a>Evaluation Metrics（评价指标）</h3><p>针对完形填空类和多项选择类的问题常用accuracy也就是准确率，答案抽取类的问题常用Exact Match，精确匹配度，也就是预测结果和ground truth完全相同的比例。</p>
<p>另外，F1 Score也常被用于答案抽取类的任务当中。此时F1的TP、FP、TN、FN定义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>tokens in reference</th>
<th>tokens not in reference</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokens in candidate</td>
<td>TP</td>
<td>FP</td>
</tr>
<tr>
<td>tokens not in candidate</td>
<td>FN</td>
<td>TN</td>
</tr>
</tbody>
</table>
</div>
<p>precision = TP / (TP + FP)，recall = TP/ (TP + FN)，F1 = 2 PR / (P+ R)。相比于EM，F1的评判标准在预测结果和ground truth有所重叠的时候更为松弛。</p>
<p>而对于自由问答类的问题，常用BLEU（常用于MT等文本生成的任务当中）等评价指标进行评价。</p>
<h2 id="General-Architecture"><a href="#General-Architecture" class="headerlink" title="General Architecture"></a>General Architecture</h2><p>目前，经典的基于深度学习的MRC模型主要包括以下几层模块：</p>
<ol>
<li>嵌入模块：因为机器并不能直接理解自然语言，所有在几乎所有NLP任务当中都需要有一个嵌入模块吧输入的单词转换成定长的向量，来作为这个模型的输入。传统的词表征方法如one-hot或者word2vec以及这些方法和其他语言学特征的结合使用，通常会用来表征一个词当中的语义和句法信息。除此之外，最近由大规模语言预训练模型所得到的上下文词表征在编码上下文信息时也表现出显著的优越性。</li>
<li>特征提取模块：在嵌入模块把文章和问题作词嵌入之后接着输入到特征提取模块。为了更好理解文章和问题，这个模块旨在提取出更多的上下文信息，常用RNN或者CNN来进行提取。</li>
<li>文章-问题交互模块。文章和问题之间的一些相互关系信息在答案预测时常常有举足轻重的作用。这种相互关系的信息可以帮助机器确定文章中的哪一部分的内容是回答问题的关键。此阶段常常使用unidirection或者bidirection的attention机制来完成协同关系信息提取的任务。有时，为了比较完全地提取出文章和问题的相互关系信息，文章和问题之间的交互操作会进行多次，这也正是受到人类进行阅读理解是多次反复阅读来回答问题的经验所启发得出的一种技巧。</li>
<li>答案预测模块：答案预测模块是MRC系统当中的最后一个模块，用以估计文章和问题的输入最终输出对于问题答案的预测。这一模块的具体设计依赖于之前所述的不同的MRC任务。</li>
</ol>
<h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>从上述的四个模块分别详细介绍了这些模块可能使用的方法：</p>
<h3 id="Embeddings"><a href="#Embeddings" class="headerlink" title="Embeddings"></a>Embeddings</h3><p>Embedding的方法有三种，分别是传统的词表征、预训练的上下文表征以及多粒度的联合表征。</p>
<ul>
<li>传统的词表征包括One-Hot和Distributed Word Representation。</li>
<li>预训练的上下文表征则是由各类语言预训练模型所得到的表征，如CoVE、ELMo、GPT、BERT。</li>
<li>多粒度的联合表征是指word-level的嵌入不能够把丰富的语法、句法以及各类语言学信息完整地嵌入到向量当中，比如part-of-speech以及词缀等，那多粒度的联合表征就是从这些方面入手，把多个粒度的信息嵌入到联合表征当种，如Character Embeddings、Part-of-speech Tags、Name-Entity Tags、Binary Feature of Exact Match (whether a context word is in the question）、Query-Category（问题的种类）</li>
</ul>
<h3 id="Feature-Extraction"><a href="#Feature-Extraction" class="headerlink" title="Feature Extraction"></a>Feature Extraction</h3><p>这个特征提取模块通常位于EMbedding层之后，用于分别对文章和问题进行特征的提取。通常就是一个bi-LSTM、CNN或者Transformer。</p>
<ul>
<li>RNN模型：常用bi-LSTM训练得到word-level或者sentence-level（就是把两层LSTM各自最后一个单元的隐层向量拼接在一起），尽管RNNs的方法对于序列信息的获取十分有效，但是由于其不可并行性导致极其难以训练。</li>
<li>CNNs模型：经典TextCNN得到整个句子的特征提取向量。优点是可以并行训练，且对于局部信息的提出非常精炼有效，但是对于长句子的特征提取能力十分有限。</li>
<li>Transformer模型：Transformer主要依据attention机制，相比于RNN，此模型更容易训练，相比于CNN，此模型能更有效地提取出文本信息种的全局依赖性。QANet就是一个经典的基于Transformer的MRC模型。</li>
</ul>
<h3 id="Context-Question-Interaction"><a href="#Context-Question-Interaction" class="headerlink" title="Context-Question Interaction"></a>Context-Question Interaction</h3><p>通过提取文章和问题中的相互关系信息，MRC模型便能够从中挖掘出进行答案预测的线索。用于提取文章和问题的相互关系信息的模型可以分为one-hop和multi-hop。无论是哪种类型的交互模块，attention机制都起着至关重要的的作用。</p>
<p>MRC的attention机制可以分为unidirectional attention和bidirectional attention</p>
<ol>
<li>Unidirectional Attention<br>Unidirectional Attention通常是从问题到文章的一个attention操作，用于突出文章中和问题最相关的部分。通常是使用一个sentenc-level的embedding得到问题句子的嵌入向量，而后以此问题句子嵌入向量和文章中单词的词嵌入作attention操作：<script type="math/tex">S_i=f(P_i, Q)</script>。然而这种方法忽略了问题句子中的单词对于答案预测的影响。所以unidirectional attention并不足以充分提取文章和问题之间的相关关系信息。</li>
<li>Bidirectional Attention<br>那为了解决上述方法的缺点便引入了Bidirectional Attention即不仅仅做query-to-context的attention，同时也做context-to-query的attention，得到一个pair-wise的matching矩阵M(i,j)。M(i,j)有文章单词嵌入<script type="math/tex">P_i</script>和问题单词嵌入<script type="math/tex">q_j</script>计算。而后根据M矩阵做一个column-wise的softmax用于表示query-to-context的attention权重，row-wise的softmax表示context-to-query的attention权重。</li>
</ol>
<p><strong>Multi-Hop Interaction</strong>：one-hop的模型文章和问题之间的交互只做一次，不能够系统地理解问题和文章之间的相互信息，而导致不足以解决一些复杂的MRC问题，如从多个句子的文章中做答案的预测。因而便引出了multi-hop的交互。multi-hop的交互模块得益于先前文章和问题的记忆，能够深层次地提取出文章和问题的相互关系，从而得到进行答案预测的线索。</p>
<h3 id="Answer-Prediction"><a href="#Answer-Prediction" class="headerlink" title="Answer Prediction"></a>Answer Prediction</h3><p>答案预测模块通常是MRC系统的最后一个模块，这个模块通常是根据不同任务的目标进行定义的，如先前提到的MRC的四类任务。</p>
<ol>
<li>Word Predictor：常见的做法是用query-aware的context表征去匹配词表或者候选集。</li>
<li><p>Option Selector：常见的做法是使用attentive的context表征和候选答案的表征进行相似度计算，并选出和context表征相似度最高的候选答案作为最终预测的答案。</p>
</li>
<li><p>Span Extractor：通常是用一个Boundary Model来预测答案的开始和结束的位置。</p>
</li>
<li>Answer Generator：通常使用文本的生成模型进行答案文本的生成。</li>
</ol>
<h3 id="Other-Tricks"><a href="#Other-Tricks" class="headerlink" title="Other Tricks"></a>Other Tricks</h3><ol>
<li><p>Reinforcement Learning: 大部分的MRC模型只使用极大似然估计来进行训练时的目标决策。然而，这样的目标函数和实际的评价指标并没有直接的联系。这就可能会导致，一些和正确答案有重叠但又不是完全正确的预测结果被模型忽略了，而不能对模型的训练做出一些贡献。而且，当正确答案很长或没有明确的边界时，模型很难提取出完全正确的答案。但是，却不能直接用评价指标如EM、F1等作为目标函数，因为这些评价指标都是不可微分的，不能进行神经网络的训练。因此，<a href="https://arxiv.org/abs/1711.00106" target="_blank" rel="noopener">Xiong et al.</a>和<a href="https://www.ijcai.org/Proceedings/2018/0570.pdf" target="_blank" rel="noopener"> Hu et al.</a>便提出使用强化学习的方法，将F1 score作为reward function，把极大似然估计的神经网络的训练和强化学习任务作为多任务学习的问题。除此之外，强化学习的方法也能被用在multi-hop的交互模块决定是否提交交互的进程，如<a href="https://arxiv.org/abs/1609.05284" target="_blank" rel="noopener">ReasonNets</a></p>
</li>
<li><p>Answer Ranker: 通常的做法是先提取出一个答案的候选集，之后计算这个答案候选集中的候选答案和问题表征的相似度，选择相似度最大的候选答案作为最终答案。</p>
</li>
<li>Sentence Selector: 通常，MRC问题的文章是一个非常长的文档，在这一整篇文档中寻找答案是一件非常耗时的事情。然而，找到最相关的句子可能会加速后续的训练过程。<a href>Min<br>et al.</a>受此启发，提出了一个句子选择器，来得到真正对回答问题有用的句子最小集。具体来说，这个句子选择器是一个seq2seq的模型，encoder用于计算文章的句子和问题句子的encodings，decoder用来计算文章句子和问题句子的相似度。超过某个阈值的句子将作为最终MRC系统的输入。而且输入句子的数量会根据不同的问题动态选择。</li>
</ol>
<h2 id="New-Trends"><a href="#New-Trends" class="headerlink" title="New Trends"></a>New Trends</h2><p>SQuAD2.0数据集当中包括了不可回答的问题。对于这些不可回答的问题，就出现了两个新的挑战：</p>
<ul>
<li>Unanswerable Question Detection：模型必须知道他们不知道什么。</li>
<li>Plausible Answer Discrimination：模型必须能从貌似可行的答案中分辨出正确的答案</li>
</ul>
<h2 id="Open-Issues"><a href="#Open-Issues" class="headerlink" title="Open Issues"></a>Open Issues</h2><p>目前MRC模型还有待解决的问题包括以下几点：</p>
<ul>
<li>Lack of world knowledge</li>
<li>Robustness of MRC systems</li>
<li>Limitation of given context</li>
<li>Lack of inference ability</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/论文笔记/" rel="tag"># 论文笔记</a>
          
            <a href="/tags/NLP/" rel="tag"># NLP</a>
          
            <a href="/tags/机器阅读理解/" rel="tag"># 机器阅读理解</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/30/Pre-trained-Models-for-Natural-Language-Processing-A-Survey/" rel="next" title="论文笔记：Pre-trained Models for Natural Language Processing：A Survey">
                <i class="fa fa-chevron-left"></i> 论文笔记：Pre-trained Models for Natural Language Processing：A Survey
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fadedcosine.github.io/2020/04/30/Pre-trained-Models-for-Natural-Language-Processing-A-Survey/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cosine">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Zoe.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cosine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">论文笔记：Pre-trained Models for Natural Language Processing：A Survey</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-30T15:48:18+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/千里怀思月在峰/" itemprop="url" rel="index">
                    <span itemprop="name">千里怀思月在峰</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Pre-trained-Models-for-Natural-Language-Processing-A-Survey"><a href="#Pre-trained-Models-for-Natural-Language-Processing-A-Survey" class="headerlink" title="Pre-trained Models for Natural Language Processing: A Survey"></a>Pre-trained Models for Natural Language Processing: A Survey</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>关于预训练模型的一篇很好的Survey，总结了从word2vec时代静态的文本表征到目前后BERT时代，PTMs提取出的动态文本表征。PTMs的不同主要体现在模型所用的上下文encoder不同、预训练模型的任务不同、以及PTMs所针对的下游任务等。</p>
<a id="more"></a>
<h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>关于语言预训练模型的一个survey</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Neural-Contextual-Encoders"><a href="#Neural-Contextual-Encoders" class="headerlink" title="Neural Contextual Encoders"></a>Neural Contextual Encoders</h3><p>神经网络的上下文编码器：</p>
<ul>
<li>Covolutional model：通过卷积操作提取局部的上下文信息。优点是非常容易训练，并且能够获取局部信息</li>
<li>Sequential models：序列模型如RNNs，bi-RNN用于提取上下文信息，但是序列模型的表现经常受到文本中的长距离依赖因素的影响。</li>
<li>Graph-based model：基于图的模型通常把文本看作是节点，使用一些语言学的结构，如语义结构、句法结构来训练上下文表征。<font color="red"> 注意相应的参考文献：《Exploiting<br>semantics in neural machine translation with graph<br>convolutional networks》值得一读。 </font><br>缺点是得到这样的一个语言学结构特别困难，而且也非常依赖一些其他的解析器，如句法依存分析的解析器。实际上的做法是用self-attention，比如Transformer，让model自己去学习这些潜在的语言学结构信息，也就是并不用一些其他显式的做法。</li>
</ul>
<p>虽然Transformer通过对每个词之间的dependency建模，解决了卷积方法和序列方法的长距离依赖问题，但这又导致Transformer需要很大的训练集，如果训练集小了又容易过拟合。</p>
<h2 id="Overview-of-PTMs"><a href="#Overview-of-PTMs" class="headerlink" title="Overview of PTMs"></a>Overview of PTMs</h2><p>不同的PTM的区别主要在contextual encoders、pre-training tasks, and purposes，之前的Neural Contextual Encoder一节已经简单介绍过了contextual encoders。</p>
<h3 id="Pre-training-Tasks"><a href="#Pre-training-Tasks" class="headerlink" title="Pre-training Tasks"></a>Pre-training Tasks</h3><p>在CV领域的预训练模型通常是在大规模的监督学习数据集中训练的，如ImageNet。而在NLP领域，除了在machine translation有大规模的有监督数据集，其他nlp领域有监督的数据集匮乏。而其实也有基于MT领域的有监督数据集训练的预训练语言模型<a href="https://arxiv.org/abs/1708.00107" target="_blank" rel="noopener">CoVe</a>。</p>
<ol>
<li>Language Model</li>
</ol>
<script type="math/tex; mode=display">
p(x_t|x_{0:t-1}) = g_{LM}(f_{enc}x_{0:t-1})</script><p>表示$x<em>{0:t-1}$用neural encoder$f</em>{enc}(·)$做了上下文嵌入，经过prediction层$g_{LM}(·)$得到下一个单词$x_t$的条件概率。</p>
<ol>
<li>Masked Language Modeling（MLM)</li>
</ol>
<p>BERT的MLM的做法是：<br>随机mask语料中15%的token，然后预测masked token，那么masked token 位置输出的final hidden vectors喂给softmax网络即可得到masked token的预测结果。</p>
<p>这样操作存在一个问题，fine-tuning的时候没有[MASK] token，因此存在pre-training和fine-tuning之间的mismatch，为了解决这个问题，采用了下面的策略：</p>
<p>80%的时间中：将选中的词用[MASK]token来代替，例如</p>
<blockquote>
<p>my dog is hairy → my dog is [MASK]</p>
</blockquote>
<p>10%的时间中：将选中的词用任意的词来进行代替，例如</p>
<blockquote>
<p>my dog is hairy → my dog is apple</p>
</blockquote>
<p>10%的时间中：选中的词不发生变化，例如</p>
<blockquote>
<p>my dog is hairy → my dog is hairy</p>
</blockquote>
<p>这样存在另一个问题在于在训练过程中只有15%的token被预测，正常的语言模型实际上是预测每个token的，因此Masked LM相比正常LM会收敛地慢一些，后面的实验也的确证实了这一点。</p>
<p>MLM也存在一些变种，如Seq2Seq MLM，主要的预训练模型包括<a href="https://arxiv.org/abs/1905.02450" target="_blank" rel="noopener">MASS</a>和<a href="https://arxiv.org/abs/1910.10683" target="_blank" rel="noopener">T5</a>，显而易见，这个Seq2Seq的MLM所训练出来的预训练模型在Seq2Seq的下游任务肯定会有提升，比如说QA，summarization和MT。<br>Enhanced Masked Language Modeling (E-MLM)：RoBERTa把静态的Masking改成了动态的，即一开始把预训练的数据复制10份，每一份都随机选择15%的Tokens进行Masking，也就是说，同样的一句话有10种不同的mask方式。然后每份数据都训练N/10个epoch。这就相当于在这N个epoch的训练中，每个序列的被mask的tokens是会变化的。<a href="https://arxiv.org/abs/1907.12412" target="_blank" rel="noopener">ERNIE</a>的改进是不是mask一个单词，而是mask一些短语或者说命名实体（我觉得这样的预训练方式可能会对answer-span类型的QA有所改进）</p>
<ol>
<li><p>Permuted Language Modeling (PLM)<br>因为MLM在训练时的一些特殊token如[MASK]在下游任务用于预测的实际文本中是不存在的，这就导致在train和fine-turning之间可能会出现差距。那PLM的做法就是，给定一个句子，从这个句子中随机采样一个排列，接着将排列序列中的一些 token 选定为目标，同时训练模型以根据其余 token 和目标的正常位置（natural position）来预测这些目标。</p>
</li>
<li><p>Denoising Autoencoder (DAE)<br>去噪自编码器（denoising autoencoder，DAE）接受部分损坏的输入，并以重建这些未失真的原始输入为目标。在自然语言处理的下游任务中，常用Transformer来重建文本。在构建训练文本时有一些不同的制造噪声的方式。</p>
</li>
<li><p>Contrastive Learning (CTL)<br>一些文本对在语义上比随机取样的文本更为接近。CTL 背后的原理是「在对比中学习」。相较于语言建模，CTL 的计算复杂度更低，因而在预训练中是理想的替代训练标准。CTL包括</p>
</li>
</ol>
<ul>
<li>Replaced Token Detection (RTD) </li>
</ul>
<p>与Noise-Contrastive Estimation (NCE就相当于word2vec中的负采样) 相同，但RTD会根据上下文语境来预测当前的token是否是被替换过的token。<br><a href="https://arxiv.org/pdf/2003.10555.pdf" target="_blank" rel="noopener">ELECTRA</a>就是这样一个牛批的预训练模型。ELECTRA在以RTD为训练目标的同时还用了生成对抗模型的思想。ELECTRA和BERT最大的不同应该是在于两个方面：masked(replaced) tokens的选择和training objective。</p>
<p>第一，masked token的选择在BERT中是随机的，这意味着什么呢？比如句子“我想吃苹果”，BERT可以mask为“我想吃苹[MASK]”，这样一来实际上去学它就很简单，如果mask为“我[MASK]吃苹果”，那么去学这个“想”就相对困难了。换句话说，BERT的mask可能会有很多简单的token，去学这些token就算是简单的bilstm都可以做的。这样一来，自然而然的一个想法是，我们不随机mask，去专门选那些对模型来说学习困难的token。怎么做呢？这就是ELECTRA非常牛逼的地方了，ELECTRA有一个生成器和鉴别器，生成器将用来把输入文本做部分词的替换，而鉴别器判断输入句子中的每个词是否被替换。也就是说，这里的生成器的作用是为自动选择tokens来替换成其他token，并且经过训练，生成器会越来越选择 一些比较难的token替换，希望骗过鉴别器。在鉴别器方面，用一个二分类去判断每个token是否已经被换过了。这就把原来BERT的一个DAE（或者LM）任务转换为了一个分类任务（或者序列标注）。这有两个好处：（1）每个token都能contribute to some extent，即每个token对模型都有所贡献；（2）极大程度减少了计算复杂度，原来BERT的复杂度是O(d*V)，d是输入文本长度，V是词表大小，那ELECTRA的复杂度就是O(d*2)。</p>
<ul>
<li>Next Sentence Prediction (NSP)</li>
</ul>
<p>训练模型以区分两个输入句子是否为训练语料库中的连续片段。正例是同一个文档的两个连续片段，负例是语料库中的随机两个文档。实际上这个训练目标并不是特别好，因为很容易根据两个句子的主题判断是否是连续的片段，从而可能会错误地引导模型去做主题预测的工作。</p>
<ul>
<li>Sentence Order Prediction (SOP)</li>
</ul>
<p>SOP 使用同一文档中的两个连续片段作为正样本，而相同的两个连续片段互换顺序作为负样本。这样就不存在主题不同的问题了。</p>
<h3 id="Model-Analysis"><a href="#Model-Analysis" class="headerlink" title="Model Analysis"></a>Model Analysis</h3><ul>
<li>Linguistic Knowledege  (语言知识)</li>
</ul>
<p>BERT在句法任务中的表现很好，但却在语义和细粒度的句法任务上表现不佳。</p>
<ul>
<li>World Knowledge</li>
</ul>
<p>BERT能够提取文本中的World Knowledge，如一些关系信息和常识。</p>
<h2 id="Extensions-of-PTMs"><a href="#Extensions-of-PTMs" class="headerlink" title="Extensions of PTMs"></a>Extensions of PTMs</h2><ul>
<li>Knowledge-Enriched PTMs</li>
</ul>
<p>加入了一些额外的信息增强了预训练模型。如改进MLM，在每个词上整合这个词的情感词性所提出的SentiLR；K-BERT显式地把从知识图谱中提取出的关系实体嵌入到BERT当中，使得以一个树形的数据作为BERT的输入；K-Adapter通过对不同的预训练任务训练不同的adapter来对不多种额外的信息做一个合适的整合，等等。</p>
<ul>
<li><p>Multi-Modal PTMs<br>暂且不看</p>
</li>
<li><p>Model Compression</p>
</li>
</ul>
<h2 id="Adapting-PTMs-to-Downstream-Tasks"><a href="#Adapting-PTMs-to-Downstream-Tasks" class="headerlink" title="Adapting PTMs to Downstream Tasks"></a>Adapting PTMs to Downstream Tasks</h2><p>尽管预训练模型能够捕获文本的general knowlegde，但怎么样高效的适用于下游任务已让是一个关键的问题。</p>
<p>把PTM适用于下游任务是一个顺序的迁移学习任务，即顺序地学习任务，并且目标任务是带有标签的。</p>
<p>那么如何做预训练模型到下游任务的迁移呢？</p>
<ol>
<li>选择一个合适的预训练任务、模型架构和下游任务训练语料库。</li>
<li>选择合适的网络层。可以选择只用BERT的第一层Embedding层，也可以直接在BERT的输出上加一层Top Layer，也可以把每一层的输入做一个加权，作为Encoder的输出。</li>
<li>fine-tuning的技巧：mult-task learning、使用额外的适配模块进行fine-tuning、gradual unfreezing</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/论文笔记/" rel="tag"># 论文笔记</a>
          
            <a href="/tags/NLP/" rel="tag"># NLP</a>
          
            <a href="/tags/预训练模型/" rel="tag"># 预训练模型</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/16/The-Entrance-Test-and-Interview-of-Pinduoduo/" rel="next" title="2020拼多多算法实习生笔试、面试记录">
                <i class="fa fa-chevron-left"></i> 2020拼多多算法实习生笔试、面试记录
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/05/Neural-Machine-Reading-Comprehension-Methods-and-Trends/" rel="prev" title="论文笔记：Neural Machine Reading Comprehension：Methods and Trends">
                论文笔记：Neural Machine Reading Comprehension：Methods and Trends <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fadedcosine.github.io/2020/04/16/The-Entrance-Test-and-Interview-of-Pinduoduo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cosine">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Zoe.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cosine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">2020拼多多算法实习生笔试、面试记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-16T14:24:11+08:00">
                2020-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/世若秋水一般凉/" itemprop="url" rel="index">
                    <span itemprop="name">世若秋水一般凉</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>拼多多笔试两小时四道题，做出来三道，最后一道题未果，后寻得答案。</p>
<blockquote>
<p>N个方块涂有颜色，玩家可以从所有的方块中任意移除最多k个方块，使得在剩余的方块中，连续相同的颜色的方块长度最长。问通过移动，可以得到的相同颜色的方块最长多长。</p>
</blockquote>
<a id="more"></a>
<p>起初以为是用dp来做，不过确实能做：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j]表示以[i]结尾，移动j个方块所能得到的最长长度；</span></span><br><span class="line"><span class="comment">//状态转移方程为：</span></span><br><span class="line"><span class="keyword">if</span>(a[i] == a[i<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">	dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过这种做法，需要的时间复杂度为O(nk)，超时了，显然不能满分。</p>
<p>实际上，正确的解法为使用滑动窗口的技巧，对于初始情况下的每一块相同颜色的色块，以该色块颜色为当前的目标颜色，维护最大<strong>移除长度</strong>为k的滑动窗口（即最多跳过k个不相同的颜色方块），记录当前窗口内，通过移除可得的最大相同长度，在依此更新全局的最大长度。不过，我寻思这样做时间复杂度也是O(nk)，只不过可能常数要小一些而已。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cicada[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;cicada[i];</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i + <span class="number">1</span> &lt; n &amp;&amp; cicada[i] == cicada[i+<span class="number">1</span>]) <span class="comment">//维护初始色块</span></span><br><span class="line">		&#123;</span><br><span class="line">			i++, len++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i + t &lt; n - <span class="number">1</span> &amp;&amp; count &lt; k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(cicada[i] == cicada[i + t]) len++;</span><br><span class="line">			<span class="keyword">else</span> count++;</span><br><span class="line">			t++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(i + t &lt; n &amp;&amp; cicada[i] == cicada[i + t])</span><br><span class="line">		&#123;</span><br><span class="line">			t++, len++;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = max(anx, len);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>面试官是一个和蔼的叔叔（真滴好和蔼呀，整个面试的过程都轻松了很多呢）太和蔼了，好感度+10，终于不会被庄小姐杀死而潜伏失败了。<br>令我吃惊的是，面试官先向我做了一个自我介绍，他是拼多多图像组的组长，工作内容是拼多多内部或者产品的一些人脸识别、图像搜索等内容。之后，大抵寻常的过程，我做了自我介绍，而他针对我的项目问了很多问题，以下作为记录：</p>
<ul>
<li><p>问：你的这篇论文工作是在哪里一些改进呢？你说是系统的响应时间，怎么看着你们使用社交网络的维度是在推荐系统的效果上做出了一些改进呢？</p>
<p>答：是的，考虑社交网络关系对于用户查询的影响的确能够在推荐系统的推荐效果上给用户以更好的对象推荐，那我所说的在响应时间上的改进是得益于我们使用用户的社交网络影响进行了一些剪枝算法的设计。首先我们使用图嵌入算法得到用户特征向量之后，使用用户之间的相似度对于用户朋友对于每个索引节点的访问次数进行加权求和之后归一化，得到用户受其社交关系的影响因子，并设定一个阈值，我们认为低于这个阈值的索引节点是在社交与当前用户不相关的节点，就剪枝掉，从而节省了很多对于不相关节点的访问时间。</p>
</li>
<li><p>问：你的鸟类图像分类这个项目中为什么要做边缘检测、去背景，难道去背景之后效果会更好嘛？</p>
<p>答：我们拿到的图片中，有些鸟类主体只占图片的非常小的一部分，我们觉得去除多余的背景，可以去除一些冗余的信息，可能会提高模型的效果。</p>
<p>问：那你去了背景之后模型效果提高了多少。</p>
<p>答：我没做对比实验</p>
<p>之后，尬住。。</p>
</li>
<li><p>问：你毕设项目中的这个验证器是什么？能具体介绍一下嘛？</p>
<p>答：</p>
</li>
<li><p>问：介绍一下CycleGAN。</p>
<p>答：我大概说了一下，这里记录一下自己说错的一点。实际上，Cycle Consistencey Loss包括的是x -&gt; G(x) -&gt;  F(G(x))中F(G(x))相对于x的loss（这个叫forward cycle consistency），还包括y -&gt; F(y) -&gt; G(F(y))中G(F(y))相对于y的loss（这个叫backward cycle consistency）。两者之和才是cycle consistency loss。</p>
</li>
<li><p>问：你的deblur项目中改进了CycleGAN模型的什么网络结构？</p>
<p>答：我们改进了CycleGAN的生成器网络，用了类似于Amulet的方法，使用多层次的特征提取，把低层次的卷积特征通过上采样的一些反卷积的操作，和后一层的feature map做concat操作。这样做就是希望一些低分辨率的粗糙去模糊图片引导高分辨率的去模糊图片的生成。</p>
</li>
<li><p>（我自己）问：什么是反卷积？</p>
<p>（知乎）答：在应用在计算机视觉的深度学习领域，由于输入图像通过卷积神经网络(CNN)提取特征后，输出的尺寸往往会变小，而有时我们需要将图像恢复到原来的尺寸以便进行进一步的计算，这个采用扩大图像尺寸，实现图像由小分辨率到大分辨率的映射的操作，叫做上采样。而反卷积是一个常用的上采样方法，那反卷积是一种特殊的正向卷积，先按照一定的比例通过补0来扩大输入图像的尺寸，再进行正向卷积（也就是根据要上采样到的图片大小，进行补0，在对补0之后的矩阵做正向卷积）所以反卷积只能恢复尺寸，而不能恢复数值。</p>
</li>
<li><p>问：SSIM loss是什么？</p>
<p>答：SSIM loss是基于样本x和y之间三个方面的比较，分别是亮度、对比度和结构，SSIM loss改进了MSE不能衡量图像结构相似性的缺陷（SSIM越大，两个图像之间的差距越小）。</p>
</li>
<li><p>问：介绍一下3D表面重建的Matching Cube算法。</p>
<p>答：首先我们这个点云空间被分为k <em> k </em> k个小方块，也就是所谓的体素，存在模型点的体素，我们称为实体素，不存在的成为虚体素。定义体元是由8个相邻的体素所构成的正方体。而我们要做的3D表面重建就是在做3D模型表面的三角形面片的重建。那位于3D模型表面的体元的8个体素点都可能是实体素点或者虚体素点，那只有一共有2的8次方种情况，也就是256种情况。Matching Cube的思想就是利用这256种可枚举的情况来进行体元内3D模型表面的抽取。那这么抽取呢，举个例子，如果在边界体元中，A体素是实体素，B体素是虚体素，那这个表面就一定经过A和B的中点位置。也就是根据这样的表面划分方法，通过关注边界的体元，我们就能进行3D模型的表面重建。</p>
</li>
<li><p>问：我看你都是在做一些深度学习的内容，你对传统的机器学习了解吗。介绍一下GBDT。</p>
</li>
<li><p>问：介绍一下决策树的种类。（我并不是很懂这个问题，于是说了决策树的生成过程，这里试着回答这个问题。）</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/笔试/" rel="tag"># 笔试</a>
          
            <a href="/tags/面经/" rel="tag"># 面经</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/14/The-introspection-of-Tencent-game-security-technology-competition/" rel="next" title="广告文本多分类——2020腾讯游戏安全技术决赛反思">
                <i class="fa fa-chevron-left"></i> 广告文本多分类——2020腾讯游戏安全技术决赛反思
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/30/Pre-trained-Models-for-Natural-Language-Processing-A-Survey/" rel="prev" title="论文笔记：Pre-trained Models for Natural Language Processing：A Survey">
                论文笔记：Pre-trained Models for Natural Language Processing：A Survey <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fadedcosine.github.io/2020/04/14/The-introspection-of-Tencent-game-security-technology-competition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cosine">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Zoe.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cosine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">广告文本多分类——2020腾讯游戏安全技术决赛反思</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-14T20:12:31+08:00">
                2020-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人如春色三分淡/" itemprop="url" rel="index">
                    <span itemprop="name">人如春色三分淡</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>四月初的天气时常阴晴未定。</p>
<p>由于好兄弟去年参加了这个比赛的缘故（见<a href="https://blog.csdn.net/Code_Tookie/article/details/88819298" target="_blank" rel="noopener">他的博客</a>），我今年也尝试报名参赛，并也进入决赛，不过可惜只拿到优秀奖。我自己甚是失望，故属文于此，记录下整个答题过程和反思。</p>
<h3 id="1-数据分析"><a href="#1-数据分析" class="headerlink" title="1. 数据分析"></a>1. 数据分析</h3><p>赛事方提供的游戏部分公开言语数据（中文），每条记录包括了言语内容本身和对应的细分类标签（正常和4种广告细分类，共5个分类）。首先我对数据进行初步分析，得到数据的数量分布以及对应的标签含义如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>数据标签</strong></th>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数量/条</strong></td>
<td>73034</td>
<td>25466</td>
<td>500</td>
<td>1000</td>
<td>2000</td>
</tr>
<tr>
<td><strong>标签含义</strong></td>
<td>普通非广告文本</td>
<td>出资源广告</td>
<td>退款广告</td>
<td>社交广告</td>
<td>代练广告</td>
</tr>
</tbody>
</table>
</div>
<p>​    由此可见，各类标签的数据十分不均衡，因此我做了以下两种数据增强操作。</p>
<a id="more"></a>
<p>1)   分词数据增强：我首先设定均衡的数据分布比例为4:1:1:1:1，而后我使用jieba分词将文本进行分词操作。分词之后，对于文本的分词进行两种操作，一是随机地进行删除，二是 shuffle, 即打乱词序，得到通过分词进行数据增强之后的训练集；</p>
<p>2)   反向翻译数据增强：反向翻译的主要思想是先将机器翻译成另一种语言，再从另一种语言的文本翻译回原先语言，从而进行数据增强。我按照设定的数据分布比例，使用腾讯AI开放平台提供的文本翻译（翻译君）API进行反向翻译数据增强。</p>
<p>经过数据增强，各标签数据的比例大约在4:1:1:1:1，总的数据量到达了293490条。</p>
<h3 id="2-模型建立"><a href="#2-模型建立" class="headerlink" title="2. 模型建立"></a>2. 模型建立</h3><p>我实际上实现了两个模型，BERT与TextCNN。</p>
<p>因为Pytorch和Transformers的框架下，就已经有了文本分类的API，用BERT的中文分词器处理完数据之后就可以很简单的直接训练，具体可以参考我滴好兄弟的<a href="https://blog.csdn.net/Code_Tookie/article/details/104944888" target="_blank" rel="noopener">另一篇博客</a>。</p>
<p>而TextCNN则十分常规的embedding+convd+maxpooling+output的网络结构，实现起来也轻而易举，分词则是用jieba这个分词库。</p>
<p>以上就是就是我模型的建立，由于本文重点在反思部分，故此处便不再叨唠。</p>
<h3 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3. 测试效果"></a>3. 测试效果</h3><p>BERT的多分类模型，在我9:1划分的测试集上的结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Accuracy</strong></th>
<th><strong>Precision</strong></th>
<th><strong>Recall</strong></th>
<th><strong>F1</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>97.5926%</td>
<td>97.76%</td>
<td>97.80%</td>
<td>97.71%</td>
</tr>
</tbody>
</table>
</div>
<p>看着这么高的表现只不过是镜花水月。实际上我得知自己只有优秀奖之后向赛事方寻求了测试集的部分数据，其数据的数量分布如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>数据标签</strong></th>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数量/条</strong></td>
<td>12110</td>
<td>2447</td>
<td>287</td>
<td>620</td>
<td>1269</td>
</tr>
</tbody>
</table>
</div>
<p>可以发现，测试集的数据分布其实和训练集是十分接近的，而我训练的BERT模型在测试集上的测试效果则不堪入目：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Accuracy</strong></th>
<th><strong>Precision</strong></th>
<th><strong>Recall</strong></th>
<th><strong>F1</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>87.0805%</td>
<td>27.85%</td>
<td>17.23%</td>
<td>21.78%</td>
</tr>
</tbody>
</table>
</div>
<p>而TextCNN的模型在测试集上却有不错的效果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Accuracy</strong></th>
<th><strong>Precision</strong></th>
<th><strong>Recall</strong></th>
<th><strong>F1</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>86.85%</td>
<td>88.87%</td>
<td>60.31%</td>
<td>79.46%</td>
</tr>
</tbody>
</table>
</div>
<p>认真debug一晚上之后，发现是在BERT模型中做预测时，调用forward的时候少传了一个参数，预测部分的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">..........</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step, batch <span class="keyword">in</span> enumerate(test_dataloader):</span><br><span class="line">        <span class="keyword">if</span> step % <span class="number">40</span> == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> step == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'  Batch &#123;:&gt;5,&#125;  of  &#123;:&gt;5,&#125;.'</span>.format(step, len(test_dataloader)))</span><br><span class="line">        batch = tuple(t.to(device) <span class="keyword">for</span> t <span class="keyword">in</span> batch)</span><br><span class="line">        <span class="comment"># b_input_ids, b_input_mask = batch</span></span><br><span class="line">        b_input_ids, b_input_mask, b_labels = batch</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            outputs = model(b_input_ids,</span><br><span class="line">                    token_type_ids=<span class="literal">None</span>,</span><br><span class="line">                    attention_mask=b_input_mask <span class="comment">#在提交答卷时少传了这个attention_mask</span></span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">        logits = outputs[<span class="number">0</span>]</span><br><span class="line">        logits = logits.detach().cpu().numpy()</span><br><span class="line">        label_ids = b_labels.to(<span class="string">'cpu'</span>).numpy()</span><br><span class="line"></span><br><span class="line">.............</span><br></pre></td></tr></table></figure>
<p>attention_mask的作用是用于指示输入的文本，如果是PAD符号则是0，否则就是1。无论在训练还是预测，这都是一个十分重要的参数，我竟然漏了这个参数，实属nt。还有一个很重要的原因是，由于本地GPU不够跑BERT，而我又暂时没有服务器，只能在colab上跑程序，当时做预测时，只用了非常小（10行）的一个测试集，发现都正确之后便没有再检查了。出现如此低级错误，实在是不能接受。</p>
<p>不过现在的懊恼都已经弃我去者，昨日之日不可留了。希望以此为戒，乞求拜托今日之日的烦忧。</p>
<p>debug之后，BERT模型正确的测试代码的测试结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Accuracy</strong></th>
<th><strong>Precision</strong></th>
<th><strong>Recall</strong></th>
<th><strong>F1</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>87.08%</td>
<td>88.20%</td>
<td>61.57%</td>
<td>79.60%</td>
</tr>
</tbody>
</table>
</div>
<p>相比于TextCNN只有一点点的提升。考虑到测试文本中存在很多的非中文噪声，如：（该例子为我手动杜撰的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4t把恩dsaiuhf223daf2元十万钻</span><br></pre></td></tr></table></figure>
<p>实际上这个广告文本的内容就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2元十万钻</span><br></pre></td></tr></table></figure>
<p>所以我清洗了文本中的非中文字符。注意，可能存在其他正常的文本中本就出现非中文字符，所以这种清洗方式可能并不是最合适的。清洗之后BERT模型的表现略有上升：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Accuracy</strong></th>
<th><strong>Precision</strong></th>
<th><strong>Recall</strong></th>
<th><strong>F1</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>87.33%</td>
<td>88.61%</td>
<td>62.35%</td>
<td>80.17%</td>
</tr>
</tbody>
</table>
</div>
<p>以上，这次大赛的工作就告一段落了。之后，我向主办方了解到广告文本多分类第一名的F1达到了89.3%，确实存在比较大的差距。总结来说我觉得自己的工作可以改进的部分如下：</p>
<ol>
<li>对于文本多分类问题，还只是用了最基础的BERT预训练模型加上一层decoder，可能忽略了其他一些重要的信息，decoder可能过于简单，也许可以参考最近的论文做更多设计。</li>
<li>可能数据的预处理部分存在问题，数据增强部分设定的数据分布比例可能必不合理，相反强行拉成4:1:1:1:1可能造成模型从这个数据分布获取了一些其他并不准确的特征信息。另外，数据清洗部分的做法也有待考虑。</li>
<li>我以后一定要换一台本地可以跑BERT的代码，或者自己有一张卡，不愿上colab薅资本主义恶臭的的羊毛（其实是因为colab老是断开连接，GPU用久了还给我限额）。</li>
</ol>
<hr>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><p>在听 Jony J 的 My Man 时收到了腾讯面试官的来电，便开始了一次忽如而至的面试，听声音面试官是个和蔼的靓仔。</p>
<p>面试的流程大抵寻常，自我介绍、项目介绍、针对项目进行提问。</p>
<p>我介绍完自己用ALBERT做的机器阅读理解的毕业设计之后，他问了我一些问题：</p>
<ul>
<li><p>问：ALBERT相较于BERT的改进。</p>
<p>答：极大程度地减少了参数量；</p>
</li>
<li><p>问：Multi-Head Attention的作用。</p>
<p>答：让模型去关注不同方面的信息，比如说一些底层的Head去关注一次低层的识别，如关注位置信息、关注语法信息、关注罕见词，而高层的Head去对整个句子做一些高层次的理解；</p>
</li>
<li><p>问：前馈神经网络的作用。</p>
<p>答：其实就是全连接层的作用，Multi-Head Attention/卷积对数据进行处理后得到了数据的局部特征，而前馈神经网络/全连接层的作用就是把之前的局部特征通过权值矩阵进行整合，方便进行后续下游任务的处理；</p>
</li>
<li><p>问：你为什么认为BERT这些预训练模型不能提取文本信息中的句法和语义信息？</p>
<p>答：我是从BERT模型的训练方式MLM和Next Sentence Prediction，说明其只能对上下文信息做比较好的提取，而没有显性考虑文本中的语义和句法信息；</p>
</li>
<li><p>问：怎么理解语义？你对语义是怎么处理的？</p>
</li>
<li><p>问：你们又是怎么处理句法的呢？</p>
</li>
<li><p>问：你说用了斯坦福的句法依存分析的API，介绍一下这个句法依存分析的原理：</p>
</li>
<li><p>问：句法和语义信息中的位置信息你们是怎么处理的呢？</p>
</li>
</ul>
<p>接着又让我介绍了一下我的论文工作，针对我的论文问的问题我大多都回答得不错，其中有些印象深刻的问题：</p>
<ul>
<li><p>问：对于推荐系统中的冷启动问题，你们是怎么处理的？</p>
<p>答：（其实没有处理）emmm，确实存在冷启动问题，那我们使用的解决冷启动问题的方法是设定了一个地理位置信息对象的种类熵，也就是把熵的概念应用在店铺的种类分布之下，把这个种类熵作为基于索引的搜索过程中的一种评价指标，熵越大表示当前索引节点下的店铺种类越多，而这样的做法恰恰也是倾向于给用户提供多样性的选择，也就是推荐系统当中一种常用的解决冷启动问题的方法。</p>
</li>
<li><p>问：相对于Baseline，你们的模型取得了怎么样的提升？</p>
<p>答：从响应时间上对比，100条真实的搜索，我们的平均响应时间为15秒，也就是平均每条0.15秒。另外我们实现了传统的Spatial Keywords Query中的IR树模型作为baseline，而这个模型的响应时间，100条真实的搜索，平均响应时间为30秒，也就是平均每条0.3秒。也就是说我们的模型快乐以北，那作为trade-off，由于我们的模型引入了新的维度的特征，在索引的大小上有了一定度的增大。</p>
</li>
</ul>
<p>最后让我介绍了这次大赛的工作，我主要说了自己做的数据增强工作（说出来其实很水），接着面试官小哥问了一些问题：</p>
<ul>
<li><p>问：如何对文本是如何做分词的呢？</p>
<p>答：我说用BERT原来的中文tokenization，但实际上原来的tokenization并不是传统意义上的分词，而是把文本分成一个个单字，而BERT就是基于单字的表示，也就相当于BERT模型并没有做中文的分词；另一个textcnn的模型倒是用了分词，用jieba分词之后，而后使用随机词向量输入到textcnn模型中。</p>
</li>
</ul>
<p>以上便是对这次面试的大多印象，这个实习岗位是在腾讯深圳总部，工作内容是关于非法信息识别（祖安人亲妈）。希望能顺利拿到offer。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NLP/" rel="tag"># NLP</a>
          
            <a href="/tags/预训练模型/" rel="tag"># 预训练模型</a>
          
            <a href="/tags/竞赛/" rel="tag"># 竞赛</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/12/The-Odyssey-of-DP-2/" rel="next" title="The Odyssey of DP —— NOI题集拾遗">
                <i class="fa fa-chevron-left"></i> The Odyssey of DP —— NOI题集拾遗
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/16/The-Entrance-Test-and-Interview-of-Pinduoduo/" rel="prev" title="2020拼多多算法实习生笔试、面试记录">
                2020拼多多算法实习生笔试、面试记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fadedcosine.github.io/2020/02/12/The-Odyssey-of-DP-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cosine">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Zoe.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cosine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">The Odyssey of DP —— NOI题集拾遗</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-12T19:05:23+08:00">
                2020-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/千里怀思月在峰/" itemprop="url" rel="index">
                    <span itemprop="name">千里怀思月在峰</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="http://noi.openjudge.cn/ch0206/162/" target="_blank" rel="noopener">NOI 162:Post Office</a></p>
<blockquote>
<p>在一条直线坐标轴上有V个村庄，P个邮局，邮局建在村庄上，求一种建法，让V个村庄到最近邮局的距离之和最小。<br>输入：第一行包括两个整数， 1 &lt;= V &lt;= 300，1 &lt;= P &lt;= 30；第二行输入有序的村庄的位置a[i]<br>输出：输出最小的V个村庄到最近邮局的距离之和<br><strong>输入</strong><br>10 5<br>1 2 3 6 7 9 11 22 44 50<br><strong>输出</strong><br>8</p>
</blockquote>
<p>首先需要考虑到，如果对$[0, \cdots , i]$的村庄只建一座邮局，那一定是把邮局建在中央的村庄[i/2]中使得到邮局的距离和最小。以下给出证明：<br>设对于$[0, \cdots , i]$的村庄，将邮局建在$[i/2]$中得到的距离和为S，下标为i的村庄的位置为a[i]。假设只建一座邮局时，邮局建筑的最优位置为$[j]（j \ne i）$，则邮局建在[j]的距离和为$S+ abs(a[i/2] - a[j]) \times (i - i/2  -  j)$，因为 $S+ abs(a[i/2] - a[j]) \times (i - i/2  -  j)  &gt; S$，与 [j]为最优位置矛盾，所以 j = i / 2，即得证。<br>我们可以设置$dp[i][j] := [0, \cdots , i]$村庄中建j座村庄的距离和最小值。由之前证得的定理很容易得到状态转移方程：(min_distance(i,j)表示在$[i, \cdots, j]$建一座邮局的距离和最小值)</p>
<script type="math/tex; mode=display">dp[i][j] = \min \{ dp[m][j-1] + min\_distance(m+1, i)\} | 0 \le m <  i</script><a id="more"></a>
<p>即对$0 \le m &lt;  i ，[0, \cdots, m]$的村庄建j-1个邮局，$[m+1, \cdots, i]$的村庄建一个邮局，遍历m，得到距离和最小值。代码如下，时间复杂度为$O(n^3)$：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p, v;</span><br><span class="line"><span class="keyword">int</span> villages[<span class="number">310</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">310</span>][<span class="number">31</span>];<span class="comment">// dp[i][j] 表示[0, ... , i]中j个post office的cost</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_distance</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = villages[(i + j) / <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans += <span class="built_in">abs</span>(villages[k] - mid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NOI_2_6_162</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;v, &amp;p);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">310</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">31</span>; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][k] = INF;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;villages[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i][<span class="number">1</span>] = min_distance(<span class="number">0</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= p; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; i; m++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][k] = min(dp[i][k], dp[m][k - <span class="number">1</span>] + min_distance(m + <span class="number">1</span>, i));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[v<span class="number">-1</span>][p]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://noi.openjudge.cn/ch0206/7627/" target="_blank" rel="noopener">NOI 7627:鸡蛋的硬度</a></p>
<blockquote>
<p>有n层楼，m个鸡蛋，如果鸡蛋从第a层摔下来没摔破，但是从a+1层摔下来时摔破了，那么就说这个鸡蛋的硬度是a。这些鸡蛋硬度相同，在求鸡蛋的硬度下问使用最优策略在最坏情况下所需要的扔鸡蛋次数。<br><strong>输入</strong><br>100 1<br>100 2<br><strong>输出</strong><br>100<br>14</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          
            <a href="/tags/DP/" rel="tag"># DP</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/16/The-Odyssey-of-DP-1/" rel="next" title="The Odyssey of DP —— 最大子矩阵">
                <i class="fa fa-chevron-left"></i> The Odyssey of DP —— 最大子矩阵
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/14/The-introspection-of-Tencent-game-security-technology-competition/" rel="prev" title="广告文本多分类——2020腾讯游戏安全技术决赛反思">
                广告文本多分类——2020腾讯游戏安全技术决赛反思 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fadedcosine.github.io/2020/01/16/The-Odyssey-of-DP-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cosine">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Zoe.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cosine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">The Odyssey of DP —— 最大子矩阵</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-16T11:29:46+08:00">
                2020-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/千里怀思月在峰/" itemprop="url" rel="index">
                    <span itemprop="name">千里怀思月在峰</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="1-最大连续子序列和"><a href="#1-最大连续子序列和" class="headerlink" title="1. 最大连续子序列和"></a>1. 最大连续子序列和</h4><blockquote>
<p>给定一个数字序列 $A_{1}, A_{2}, \cdots, A_{n}$，求i，j（1$\le i \le j \le n$），使得$A_{i} + \cdots + A_{j} $最大，输出这个最大和。</p>
</blockquote>
<p> 样例：</p>
<blockquote>
<p>-2 11 -4 13 -5 -2</p>
<p>显然 11+(-4)+13=20为和最大的选取情况，因此最大和为20</p>
</blockquote>
<p>使用动态规划，复杂度为O(n)的做法：设置dp[i]表示以A[i]作为末尾的连续序列的最大和，如此一来，要求的最大和其实就算dp[0]，dp[1]，$\cdots$，dp[n-1]中的最大值，下面想办法求解dp数组。</p>
<p>因为dp[i]要求必须是以A[i]作为末尾的连续序列的最大和，那么只有两种情况：</p>
<ul>
<li>这个最大和的连续序列只有一个元素，即A[i];</li>
<li>这个最大和的连续序列有多个元素，即从前面某处A[p]开始（p&lt;i），一直到A[i]结尾。</li>
</ul>
<p>对于第一种情况，最大和就是A[i]本身。对于第二种情况，最大和是dp[i-1]+A[i]。于是得到状态转移方程</p>
<script type="math/tex; mode=display">
dp[i] = max\{A[i], dp[i-1] + A[i]\}</script><a id="more"></a>
<p>依此写出代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; i++)</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    dp[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    	dp[i] = max(A[i], dp[i<span class="number">-1</span>] + A[i]);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; dp[k])</span><br><span class="line">            k = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不需要记录每个index的连续序列的最大和时可以写成以下简洁的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span><span class="comment">//一维数组的最大连续子序列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!a || n &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> themax = a[<span class="number">0</span>], curmax = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		curmax = max(a[i], curmax + a[i]);</span><br><span class="line">		themax = max(themax, curmax);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> themax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-最大子矩阵和"><a href="#2-最大子矩阵和" class="headerlink" title="2. 最大子矩阵和"></a>2. 最大子矩阵和</h4><blockquote>
<p>已知矩阵的大小定义为矩阵中所有元素的和。<br>第一行输入一个方阵的行数n，之后的n行输入方阵的每个元素，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。<br>n<br>0 -2 -7 0<br>9 2 -6 2<br>-4 1 -4 1<br>-1 8 0 -2<br>的最大子矩阵是<br>9 2<br>-4 1<br>-1 8<br>这个子矩阵的大小是15。</p>
</blockquote>
<p>直觉上来看，这个问题就是上述最大连续子序列和拓展到二维的情况。那么关键在于如何将两者联系起来。首先我们知道<strong>一定存在0$\le i \le j \le n-1$，最优解就在第i行和第j行之间，剩下的就是去确定两个列</strong>，我们可以通过遍历所有i, j的情况，针对一对确定的i, j，我们将每一列的[i, j]行之间的数各自相加。得到一个一维数组，$a[i][0] + $\cdots$ + a[j][0], $\cdots$, a[i][n-1] + $\cdots$ + a[j][n-1]$，而后对这个一维的和数组求最大连续子序列和。最后求出上述每个i, j的最大连续子序列和的最大值即为最大子矩阵和。得到一个$O(n^3)$的算法。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> matrix[MAXV][MAXV];</span><br><span class="line"><span class="keyword">int</span> tmp[MAXV]; <span class="comment">//用于保存\[i, j\]行之间的数各自相加的一维数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxSubMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;matrix[i][j]);</span><br><span class="line">	<span class="keyword">int</span> tmpsum, themax = <span class="number">-1000000000</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fill(tmp, tmp + n, <span class="number">0</span>);<span class="comment">//每次移动i的时候tmp数组清零</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++)<span class="comment">//遍历所有i, j的情况</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp[k] += matrix[j][k];<span class="comment">//重复利用tmp，因为对于i, j的遍历是先固定i，递增j，所以当j从p变为p+1时，可以利用$tmp_p$加上第p+1行的元素即可</span></span><br><span class="line">			&#125;</span><br><span class="line">			tmpsum = maxSubArray(tmp, n); <span class="comment">//上述的最大连续序列和</span></span><br><span class="line">			themax = max(themax, tmpsum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, themax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          
            <a href="/tags/DP/" rel="tag"># DP</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/06/The-Binary-Search/" rel="next" title="二分法——《算法笔记》">
                <i class="fa fa-chevron-left"></i> 二分法——《算法笔记》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/12/The-Odyssey-of-DP-2/" rel="prev" title="The Odyssey of DP —— NOI题集拾遗">
                The Odyssey of DP —— NOI题集拾遗 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fadedcosine.github.io/2020/01/06/The-Binary-Search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cosine">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Zoe.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cosine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">二分法——《算法笔记》</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-06T20:30:06+08:00">
                2020-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/三更有梦书为枕/" itemprop="url" rel="index">
                    <span itemprop="name">三更有梦书为枕</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="1-二分法适用范围"><a href="#1-二分法适用范围" class="headerlink" title="1. 二分法适用范围"></a>1. 二分法适用范围</h4><p>二分法适用在一个<strong>严格单调序列</strong>中找到给定的某个数。</p>
<h4 id="2-二分法模板提要"><a href="#2-二分法模板提要" class="headerlink" title="2. 二分法模板提要"></a>2. 二分法模板提要</h4><p>首先，在<algorithm>库中的有lower_bound()和upper_bound()两个函数，对于lower_bound()来说，它是寻找第一个满足条件“值大于等于x”的元素的位置；而对于upper_bound()来说，它是寻找第一个满足条件“值大于x”的元素的位置。对于此类<strong>寻找有序序列中第一个满足某条件的元素的位置</strong>的问题，有固定的模板，如下：</algorithm></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分区间位左闭右闭的[left, right]，初值必须能覆盖解的所有可能取值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) <span class="comment">//对于[left, right]来说，left == right意味着找到唯一位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (条件成立) <span class="comment">//条件成立，第一个满足条件的元素的位置&lt;=mid</span></span><br><span class="line">		&#123;</span><br><span class="line">			right = mid; <span class="comment">//往左子区间[left, mid]寻找</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="comment">//条件不成立，则第一个满足该条件的元素的位置&gt;mid</span></span><br><span class="line">		&#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;<span class="comment">//往右子区间[mid+1, right]寻找</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left; <span class="comment">//返回最终确定的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>另外，如果想要寻找最后一个满足”条件C“的元素的位置，则可以先求第一个满足”条件!C“的元素的位置，然后将该位置减1即可。我们也可以把上述模板改成左开右闭的二分区间来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分区间位左开右闭的(left, right]，初值必须能覆盖解的所有可能取值，并且left比最小值小1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) <span class="comment">//对于(left, right]来说，left + 1== right意味着找到唯一位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (条件成立) <span class="comment">//条件成立，第一个满足条件的元素的位置&lt;=mid</span></span><br><span class="line">		&#123;</span><br><span class="line">			right = mid; <span class="comment">//往左子区间(left, mid]寻找</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="comment">//条件不成立，则第一个满足该条件的元素的位置&gt;mid</span></span><br><span class="line">		&#123;</span><br><span class="line">			left = mid ;<span class="comment">//往右子区间(mid, right]寻找</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> right; <span class="comment">//返回最终确定的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-模板题"><a href="#3-模板题" class="headerlink" title="3. 模板题"></a>3. 模板题</h4><h5 id="3-1-木棒切割问题"><a href="#3-1-木棒切割问题" class="headerlink" title="3.1 木棒切割问题"></a>3.1 木棒切割问题</h5><blockquote>
<p>给出长度已知的 n 根木棒，每根木棒的长度可能不同，现在希望通过切割它们得到至少 k 段长度相等的木棒（长度必须为整数），问这些长度相等的木棒最长能有多长。</p>
</blockquote>
<p>根据题意可知，长度相等的木棒的长度 L 越长，可得到的长度相等的木棒的段数越少，因此这是一个单调的情况，可以二分木棒长度 L ，当最后刚好可得到 k 段木棒时的 L 值即为所求最大长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> len[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; len[i];</span><br><span class="line">		<span class="keyword">if</span> (len[i] &gt; right) right = len[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">1</span>; right++;</span><br><span class="line">	<span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			t += len[i] / mid;</span><br><span class="line">		<span class="keyword">if</span> (t &lt; k) right = mid;</span><br><span class="line">		<span class="keyword">else</span> left = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; right - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-凸多边形的最大外接圆"><a href="#3-2-凸多边形的最大外接圆" class="headerlink" title="3.2 凸多边形的最大外接圆"></a>3.2 凸多边形的最大外接圆</h5><blockquote>
<p>给出 n 个线段的长度，试将他们头尾相接（顺序任意）地组合成一个凸多边形，使得该凸多边形的外接圆（即能使凸多边形的所有顶点都在圆周上的圆）的半径最大，求该最大半径。n 不超过 $10^{5}$，线段长度均不超过100，要求算法中不涉及坐标的计算。</p>
</blockquote>
<p>对于要求的半径，当半径过小时，所有线段首位相连放在圆里面形成 n 个弦，弦所对的圆心角之和大于 360°，而当半径过大时，弦所对的圆心角之和小于360°。仔细思考，圆心角之和与对应半径是一个单调的关系，因此可以采用二分法解决。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">double</span> m[<span class="number">100005</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">double</span> min = <span class="number">101</span>, max = <span class="number">0</span>, r;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m[i];</span><br><span class="line">		<span class="keyword">if</span> (m[i] &lt; min) min = m[i];</span><br><span class="line">		max += m[i];</span><br><span class="line">	&#125;</span><br><span class="line">	min /= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (min &lt; max) &#123; <span class="comment">//左闭右闭</span></span><br><span class="line">		r = (min + max) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">double</span> degree = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">if</span> (m[i] &gt; <span class="number">2</span> * r) &#123;</span><br><span class="line">				degree = pi + <span class="number">1</span>;  <span class="comment">//存在一条弦的长度大于两倍半径，这种情况不可能发生，所以当前的半径r过小，要到其右子区间进行搜索</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> degree += <span class="built_in">asin</span>(m[i] / <span class="number">2</span> / r); <span class="comment">//求得所有弦对应的圆心角之和</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fabs</span>(degree - pi) &lt; eps) <span class="keyword">break</span>; <span class="comment">//若圆心角之和等于360°，此时的r即为正确答案</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (degree &gt; pi) min = r;<span class="comment">//大于360°，要到其右子区间[r, max]进行搜索</span></span><br><span class="line">		<span class="keyword">else</span> max = r; <span class="comment">//否则，要到其左子区间[min, r]进行搜索。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          
            <a href="/tags/二分/" rel="tag"># 二分</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/04/Divide-and-Conquer-Code-Challenging/" rel="next" title="划分、解决、合并：分治法——《挑战程序设计竞赛》">
                <i class="fa fa-chevron-left"></i> 划分、解决、合并：分治法——《挑战程序设计竞赛》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/16/The-Odyssey-of-DP-1/" rel="prev" title="The Odyssey of DP —— 最大子矩阵">
                The Odyssey of DP —— 最大子矩阵 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fadedcosine.github.io/2019/07/04/Divide-and-Conquer-Code-Challenging/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cosine">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Zoe.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cosine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">划分、解决、合并：分治法——《挑战程序设计竞赛》</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-04T19:51:30+08:00">
                2019-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/三更有梦书为枕/" itemprop="url" rel="index">
                    <span itemprop="name">三更有梦书为枕</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="4-6-1-数列上的分治法"><a href="#4-6-1-数列上的分治法" class="headerlink" title="4.6.1 数列上的分治法"></a>4.6.1 数列上的分治法</h3><blockquote>
<p>给定一个1~n的排列<script type="math/tex">a_0,a_1,\cdots, a_{n-1}</script>，求这个数列中的逆序数对。</p>
</blockquote>
<p>我们可以把一个大的数列A分成左右两个子数列B、C，那么数列A中所有的逆序对必定来自于以下三者其一：<br>(1) i,j都属于左子数列B的逆序对(i,j);<br>(2) i,j都属于右子数列C的逆序对(i,j);<br>(3) i属于B而j属于C</p>
<p>对于这(1)和(2)，可以通过递归求得，对于(3)，我们可以对数列C中的每个数字，统计数列B中比它大的数字的个数，再把结果加起来就好。代码如下，复杂度为$O(n\log n)。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line"><span class="function">ll <span class="title">merge_count</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.size();</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a.begin(), a.begin()+n/<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(a.begin() + n/<span class="number">2</span>, a.end());</span><br><span class="line">	</span><br><span class="line">	cnt += merge_count(b); <span class="comment">//(1)</span></span><br><span class="line">	cnt += merge_count(c); <span class="comment">//(2)</span></span><br><span class="line">	<span class="comment">//此时b和c就已经分别排好序了</span></span><br><span class="line">	<span class="comment">//(3)</span></span><br><span class="line">	<span class="keyword">int</span> ai = <span class="number">0</span>, bi = <span class="number">0</span>, ci = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(ai &lt; n)s</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(bi &lt; b.size() &amp;&amp; (ci == c.size() || b[bi] &lt;= c[ci])) <span class="comment">//ci == c.size()这个判断是，如果c数列已经全部找完了，剩下的全是b数列里的树，就不能看在有逆序数的存在</span></span><br><span class="line">		&#123;</span><br><span class="line">			a[ai++] = b[bi++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cnt += (n/<span class="number">2</span> -bi);</span><br><span class="line">			a[ai++] = c[ci++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, merge_count(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-6-3-平面上的分治法"><a href="#4-6-3-平面上的分治法" class="headerlink" title="4.6.3 平面上的分治法"></a>4.6.3 平面上的分治法</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          
            <a href="/tags/分治法/" rel="tag"># 分治法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/04/The-Usage-of-Deque-Code-Challenging/" rel="next" title="双端队列的运用——《挑战程序设计竞赛》">
                <i class="fa fa-chevron-left"></i> 双端队列的运用——《挑战程序设计竞赛》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/06/The-Binary-Search/" rel="prev" title="二分法——《算法笔记》">
                二分法——《算法笔记》 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fadedcosine.github.io/2019/07/04/The-Usage-of-Deque-Code-Challenging/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cosine">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Zoe.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cosine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">双端队列的运用——《挑战程序设计竞赛》</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-04T16:56:12+08:00">
                2019-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/三更有梦书为枕/" itemprop="url" rel="index">
                    <span itemprop="name">三更有梦书为枕</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>滑动最小值<br>给定一个长度为n的数列<script type="math/tex">a_0, a_1, \cdots, a_{n-1}</script>和一个整数k。求数列$b<em>i = \min{a_i,a</em>{i+1},\cdots,a_{i+k-1} }(i=0,1,\cdots,n-k)。<br>限制条件：<br>$1\le k \le n \le 10^6$, $0 \le a_i \le 10^9$</p>
</blockquote>
<p>使用双端队列可以在O(n)时间内解决这个问题。最开始时双端队列为空，然后不断维护双端队列使它按照下面的顺序，存储用于计算后面的最小值a的元素的下标。</p>
<script type="math/tex; mode=display">
设双端队列从头部开始的元素的值为x_i，则x_i < x_{i+1}且a_i < a_{i+1}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> a[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[MAX_N]; <span class="comment">//保存答案的数组</span></span><br><span class="line"><span class="keyword">int</span> deq[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>; <span class="comment">//双端队列的头部和尾部</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(s&lt;t &amp;&amp; a[deq[t<span class="number">-1</span>]] &gt;= a[i]) t--;</span><br><span class="line">		deq[t++] = i;</span><br><span class="line">		<span class="keyword">if</span>(i-k+<span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			b[i-k+<span class="number">1</span>] = a[deq[s]];</span><br><span class="line">			<span class="keyword">if</span>(deq[s] == i-k+<span class="number">1</span>)</span><br><span class="line">			&#123;<span class="comment">//从双端队列的头部删除元素</span></span><br><span class="line">				s++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n-k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d%c"</span>,b[i],i==n-k?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          
            <a href="/tags/双端队列/" rel="tag"># 双端队列</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/03/The-Usage-of-Stack-Code-Challenging/" rel="next" title="栈的运用——《挑战程序设计竞赛》">
                <i class="fa fa-chevron-left"></i> 栈的运用——《挑战程序设计竞赛》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/04/Divide-and-Conquer-Code-Challenging/" rel="prev" title="划分、解决、合并：分治法——《挑战程序设计竞赛》">
                划分、解决、合并：分治法——《挑战程序设计竞赛》 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fadedcosine.github.io/2019/07/03/The-Usage-of-Stack-Code-Challenging/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cosine">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Zoe.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cosine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">栈的运用——《挑战程序设计竞赛》</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-03T11:14:46+08:00">
                2019-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/三更有梦书为枕/" itemprop="url" rel="index">
                    <span itemprop="name">三更有梦书为枕</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="http://poj.org/problem?id=2559" target="_blank" rel="noopener">POJ 2559: Largest Rectangle in a Histogram</a></p>
<blockquote>
<p>给定从左到右n个矩形，已知这此矩形的宽度都为1，长度不完全相等，为$h_1,h_2, \cdots, h_n$。这些矩形相连排成一排，求在这些矩形包括的范围内能得到的面积最大的矩形，打印出该面积。所求矩形可以横跨多个矩形，但不能超出原有矩形所确定的范围。<br>$1\le n \le 100000$<br><strong>输入</strong><br>7 2 1 4 5 1 3 3<br><strong>输出</strong><br>8</p>
</blockquote>
<a id="more"></a>
<p><img src="//fadedcosine.github.io/2019/07/03/The-Usage-of-Stack-Code-Challenging/2559_1.jpg" alt></p>
<p>从微软面试时学到的道理，拿到一个题目想想出最简单的算法，并能让这个算法能够成功地work。首先如果确定了长方形的左端点L和右端点R，那么最大可能的高度就是<script type="math/tex">\min \{ h_i | L \le i <R \}</script>。这样我们遍历L和R，在$[L,R)$中找最小的$h_i$这样naive的算法是$O(n^3)$的复杂度。对于区间的最小值做优化，比如说用尺取法那么就可以把复杂度降为$O(n^2)$。即使这样还是不能满足这道题的数据范围。</p>
<p>假设最大的长方形的左端是L，右端是R（左闭右开），高度是H，那么一定有<script type="math/tex">h_{L-1} <H</script>和$h_R&lt;H$，并且高度<script type="math/tex">H = \min \{h_i | L \le i < R \}</script>。因此，我们可以每次固定i，找到L和R，最后再遍历一遍找到$(R-L)\times H$的最大值。即我们维护两个数组L[i]和R[i],</p>
<ul>
<li>L[i] 是从i向左找，找到第一个小于h[i]的index，而后将这个index+1的值</li>
<li>R[i]是从i向右找，找到第一个小于h[i]的index （因为右边是开的，所以这个index不用减一）</li>
</ul>
<p>使用单调栈可以非常高效地求解这个问题。考虑计算L的情况。首先定义一个栈，并且将它初始化为空，然后不断增加i的值，并维护这个栈使它按照下面的顺序存储用于推算后面L值的元素：</p>
<ul>
<li>设在栈里的元素从上到下的值为<script type="math/tex">x_i</script>，则<script type="math/tex">x_i > x_{i+1}</script>且<script type="math/tex">h_{x_i} > h_{x_{i+1}}</script><br>也就是维护一个单调栈，维护一个单调栈的作用是，每次在计算L[i]时，我们实现看栈顶的元素j，如果j满足$h_j \ge h_i$，则不断取出栈顶元素（因为我们要找到第一个小于h[i]的index）；如果栈为空，说明找到头也没找到，那么L[i]=0，如果$h_j &lt; h_i$，则L[i]=j+1。然后把i压入栈中。</li>
</ul>
<p>由于栈的压入和弹出操作都是$O(n)$次，因此这个算法的复杂度就是$O(n)$，对于R[i]也可以用同样的方法计算。题解代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> L[<span class="number">100010</span>], R[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!= EOF &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(!left.empty() &amp;&amp; h[left.top()]&gt;=h[i]) left.pop();</span><br><span class="line">           L[i] = left.empty()? <span class="number">0</span> : (left.top() + <span class="number">1</span>);</span><br><span class="line">           left.push(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; right;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(!right.empty() &amp;&amp; h[right.top()]&gt;=h[i]) right.pop();</span><br><span class="line">           R[i] = right.empty()? n : (right.top());</span><br><span class="line">           right.push(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           res = max(res,(<span class="keyword">long</span> <span class="keyword">long</span>)(R[i] - L[i])*h[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></p>
<blockquote>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p>
</blockquote>
<p><img src="//fadedcosine.github.io/2019/07/03/The-Usage-of-Stack-Code-Challenging/rainwatertrap.png" alt></p>
<p>因为要积水，来自于不少于两个柱子之间的高度关系。我们在遍历数组时维护一个栈。如果当前的柱子的高度小于或等于栈顶的柱子，我们将柱子的索引入栈，意思是当前这个柱子被栈中的前一个柱子界定。如果我们发现一个柱子的高度大于栈顶的柱子，我们可以确定栈顶的柱子被当前柱子和栈顶的前一个柱子界定，因此我们可以弹出栈顶元素，并且累加由当前柱子和栈顶的前一个柱子贡献出来的积水（当前柱子和栈顶柱子的高度差乘以当前柱子和栈顶的前一个柱子的宽度）到 ans ，直到栈为空或栈顶柱子不低于当前柱子，随后把当前柱子的索引入栈。</p>
<p>这样的做法与上述的POJ2559题目的想法有异曲同工之妙。同样是维护了一个单调栈，栈中元素上到下，对应的高度递增，像一个金字塔形。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; right;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!right.empty() &amp;&amp; height[right.top()]&lt;height[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> top = height[right.top()];</span><br><span class="line">                right.pop();</span><br><span class="line">                <span class="keyword">if</span>(right.empty())<span class="keyword">break</span>;</span><br><span class="line">                ans += ((min(height[right.top()],height[i])-top) * (i-right.top()<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            right.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">盛水最多的容器</a></p>
<blockquote>
<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
</blockquote>
<p><img src="//fadedcosine.github.io/2019/07/03/The-Usage-of-Stack-Code-Challenging/question_11.jpg" alt></p>
<p>因为与上两题比较类似，我把这道题列在这儿。</p>
<p>要想围住的面积最大，需要尽量保证</p>
<ul>
<li>底边长比较大（两数在数组中的距离较远）</li>
<li>两数的最小值比较大<br>为了达到这两个目标，我们从底边长较大开始，定义两个变量 i，j 来记录两数的位置，并将其初始值置为 0 和 size-1。虽然此时底边长度最大，但由于这两条边可能都比较短，此时的面积很可能不是最大面积。现在的任务便是如何缩小底边的同时尽量获得最大的边长。</li>
</ul>
<p>不妨设此时两边边长不等，倘若将长的那一边移进，显然新的面积恒小于当前面积（因为限制当前面积的不是这条长的边，新的面积的底边长缩小，竖直边长不大于原边长）；因此要想获得更大的面积，只能移进那条较短的边。</p>
<p>按照这个思路，不断移进短的边，直到 i 和 j 相等，在移进的过程中记录最大边长即可。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator head=height.begin();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator tail=height.end()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxVoil = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=tail)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> area = (tail - head) * ((*head&lt;*tail)? *head:*tail);</span><br><span class="line">            maxVoil = maxVoil&gt;area?maxVoil:area;</span><br><span class="line">            <span class="keyword">if</span>(*head &lt; *tail) head++;</span><br><span class="line">            <span class="keyword">else</span> tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVoil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          
            <a href="/tags/栈/" rel="tag"># 栈</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/01/网络流解决问题——《挑战程序设计竞赛》/" rel="next" title="网络流解决问题——《挑战程序设计竞赛》">
                <i class="fa fa-chevron-left"></i> 网络流解决问题——《挑战程序设计竞赛》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/04/The-Usage-of-Deque-Code-Challenging/" rel="prev" title="双端队列的运用——《挑战程序设计竞赛》">
                双端队列的运用——《挑战程序设计竞赛》 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/Zoe.jpg" alt="Cosine">
            
              <p class="site-author-name" itemprop="name">Cosine</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cosine</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>


<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style="display:none">
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style="display:none">
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客
</span>
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
